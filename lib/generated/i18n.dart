import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes

// This file is automatically generated. DO NOT EDIT, all your changes would be lost.
class S implements WidgetsLocalizations {
  const S();

  static const GeneratedLocalizationsDelegate delegate =
    GeneratedLocalizationsDelegate();

  static S of(BuildContext context) => Localizations.of<S>(context, S);

  @override
  TextDirection get textDirection => TextDirection.ltr;

  String get acc_registers_description => "ACC registers";
  String get afe_registers_description => "AFE registers";
  String get all_data_transmitted_successfully => "All data transmitted successfully";
  String get auth_fail => "Authentication failed";
  String get batteryContent_1 => "Open the battery door on the bottom side of  the WatchPAT™ and insert the provided battery.";
  String get batteryContent_2 => "The flat side of the battery  goes to where the MINUS sign is depicted.";
  String get batteryContent_many_2 => "Open the battery door on the bottom side of all irrelevant WatchPAT™ ONE and remove the battery.";
  String get batteryTitle => "Insert Battery";
  String get bt_initiation_error => "Bluetooth initiation error";
  String get bt_must_be_enabled => "Bluetooth must be enabled for the test procedure.\nPlease turn Bluetooth on.";
  String get bt_not_available_shutdown => "Bluetooth is not available on this device";
  String get btnCloseApp => "Close App";
  String get btnEndRecording => "End Recording";
  String get btnEnter => "Enter";
  String get btnMore => "More";
  String get btnNext => "Next";
  String get btnPreview => "Preview";
  String get btnReady => "Ready";
  String get btnReturnToApp => "Return To App";
  String get btnStartRecording => "Start Recording";
  String get chestSensorContent => "Pull the Chest Sensor along your non dominant hand, and up to the neck opening. \nPeel the white paper from the back of the sensor. Stick the sensor to the center of your upper chest bone, just below the front of neck.";
  String get chestSensorTitle => "Attach Chest Sensor";
  String get close_app => "Close App";
  String get close_mypat_app_q => "Close myPAT Application?";
  String get connect_to_charger => "Connect the phone to a charger";
  String get connected => "Connected";
  String get connected_to_device => "Connected to device";
  String get connected_to_used_device => "Connected to a used device";
  String get connecting_to_device => "Connecting to a device";
  String get connection_to_main_device_lost => "Connection to Main Device is lost";
  String get critical_hw_failure => "Critical hardware failure";
  String get customer_service_mode => "Customer service mode";
  String get device_log_file_description => "Device log file";
  String get device_not_found => "Device is not found";
  String get device_ver_name => "DeviceFWVersion";
  String get digits => "digits";
  String get disconnect_all_irr_devices => "Disconnect all irrelevant devices";
  String get disconnected => "Disconnected";
  String get enter_id => "ID:";
  String get enter_new_serial => "Enter main device new serial number";
  String get err_actigraph_test => "Actigraph test";
  String get err_battery_low => "Battery low voltage";
  String get err_flash_test => "Flash test";
  String get err_probe_leds => "Probe LEDs";
  String get err_probe_photo => "Probe photo";
  String get err_sbp => "SBP";
  String get err_used_device => "Used main device";
  String get error_state => "ERROR STATE";
  String get exit_service_mode => "Exit service mode";
  String get fingerProbeContent => "Insert any finger, except your thumb, all the way into the probe.  \nThe sticker marked TOP should be on the top of your finger. Hold the probe against a hard surface (like a table) and pull the TOP tab toward you to remove it from the probe.";
  String get fingerProbeTitle => "Wear Finger Probe";
  String get finger_not_detected => "Finger not detected alert";
  String get firmware_alert_title => "Device firmware upgrade";
  String get flash_full => "Device flash is full";
  String get fw_check_version => "Please wait while we check device firmware version";
  String get fw_connection_failed => "Connection with main device failed. Test will be terminated.\n\nPlease contact Itamar Medical support.";
  String get fw_need_upgrade => "Main device new firmware version is available. It will not take long.\n\nPlease wait while we upgrade it&#8230;";
  String get fw_upgrade_failed => "Main device firmware upgrade failed.\n\nPlease contact Itamar Medical support.";
  String get fw_upgrade_succeed => "Main device firmware upgraded successfully";
  String get green => "green";
  String get id_in => "ID in";
  String get incorrect_pin => "Incorrect PIN, please try again";
  String get inet_unavailable => "Internet access unavailable";
  String get insufficient_storage_space_on_smartphone => "Insufficient storage space on smartphone, shutting down";
  String get invalid_id => "Invalid ID";
  String get invalid_technician_password => "Invalid technician password";
  String get loading => "Loading";
  String get log_email_subject => "myPAT device log file";
  String get low_power => "Low power alert";
  String get myPAT_connect_to_server_fail => "myPAT connection to SFTP server failure";
  String get mypat_device => "myPAT Device";
  String get no_inet_connection => "Internet connection not available";
  String get none => "None";
  String get parameters_file_description => "Parameters file";
  String get patient_msg1 => "You are advised to leave the charger plugged in during the entire test procedure and close unused applications before starting test procedure";
  String get patient_msg2 => "Please don't close myPAT application during test procedure";
  String get pinContent => "Enter your assigned four digits PIN \n(personal identification number) and tap enter";
  String get pinTitle => "Enter Pin";
  String get pleaseWait => "Please Wait";
  String get please_insert_finger => "Please insert the finger and press OK";
  String get please_plug_charger => "Please plug in a charger";
  String get please_replace_battery => "Please replace the battery in the device";
  String get product_reuse => "Product reuse attempt";
  String get ready => "Ready";
  String get recordingTitle => "Good Night";
  String get red => "Red";
  String get remote_server => "Remote Server";
  String get removeJewelryContent => "Remove tight cloths, watches and jewelry.\nEnsure that the finger nail is trimmed.\nRemove artificial nail or colored nail polish from the monitored finger.\nUse the MORE button to see more details.";
  String get removeJewelryTitle => "Remove Jewelry";
  String get scan_again => "Scan again";
  String get scanning_device => "Scanning for device";
  String get select_bit_type => "Select BIT mode";
  String get server_comm_error => "Server communication error, please contact support";
  String get sftp_server_no_access => "SFTP Server is not accessible. Error code returned";
  String get startRecordingContent => "Once the device has been properly put on, the WatchPAT™ is ready to start recording. Have a good night sleep.\nIf you need to get up during the night, do not remove the device or sensors.\nDo leave the phone behind, connected  to the charger.";
  String get startRecordingTitle => "Start Recording";
  String get start_test => "Start Test";
  String get stepperOf => "of";
  String get stepperStep => "Step";
  String get stop_test => "Stop Test";
  String get strapWristContent => "You will be putting the WatchPAT on your non-dominant hand. \nPlace the WatchPAT on a flat surface. \nInsert your hand and close the strap, making sure its snug but not too  tight.";
  String get strapWristTitle => "Strap Wrist Device";
  String get technician_mode => "Technician mode";
  String get test_data_still_transmitting_close_anyway => "Test data still transmitting Please don't close myPAT application  Close anyway?";
  String get test_data_transmit_in_progress => "Test data transmit in progress";
  String get test_in_progress => "Test in progress";
  String get thankYouContent => "The data has been successfully uploaded and the test is over.\nPlease dispose the product by your local guidance's.";
  String get thankYouTitle => "Thank You";
  String get title_led_color_alert => "Choose LED color";
  String get unknown_error => "Unknown error occurred during authentication, please contact support";
  String get uploadingContent => "Please do not close the application while the data is being uploaded.\nThe data transmission will be over in several minutes.";
  String get uploadingTitle => "Good Morning";
  String get used_device_please_replace => "This device is already used, please replace it and relaunch application";
  String get user_mode => "User mode";
  String get welcomeContent => "You are using an Application that works with the WatchPAT® device in collecting your sleep data for your physician.\nYou are about to start a few minutes of pre-sleep setup activities, after which the WatchPAT  will start its role, and you can start you good night sleep.";
  String get welcomeTitle => "Welcome";
  String get welcome_to_mypat => "Welcome to myPAT";
  String batteryContent_many_1(String devices) => "Discovered $devices devices\nPlease disconnect all except the relevant one and scan again";
  String device_sn(String sn) => "Main Device serial number $sn";
  String status(String status) => "Status: $status";
  String stepper(String step, String total) => "Step $step of $total";
  String test_length(String time) => "Test Time: $time";
  String test_status(String status) => "Test Status: $status";
}

class $en extends S {
  const $en();
}

class GeneratedLocalizationsDelegate extends LocalizationsDelegate<S> {
  const GeneratedLocalizationsDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale("en", ""),
    ];
  }

  LocaleListResolutionCallback listResolution({Locale fallback, bool withCountry = true}) {
    return (List<Locale> locales, Iterable<Locale> supported) {
      if (locales == null || locales.isEmpty) {
        return fallback ?? supported.first;
      } else {
        return _resolve(locales.first, fallback, supported, withCountry);
      }
    };
  }

  LocaleResolutionCallback resolution({Locale fallback, bool withCountry = true}) {
    return (Locale locale, Iterable<Locale> supported) {
      return _resolve(locale, fallback, supported, withCountry);
    };
  }

  @override
  Future<S> load(Locale locale) {
    final String lang = getLang(locale);
    if (lang != null) {
      switch (lang) {
        case "en":
          return SynchronousFuture<S>(const $en());
        default:
          // NO-OP.
      }
    }
    return SynchronousFuture<S>(const S());
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale, true);

  @override
  bool shouldReload(GeneratedLocalizationsDelegate old) => false;

  ///
  /// Internal method to resolve a locale from a list of locales.
  ///
  Locale _resolve(Locale locale, Locale fallback, Iterable<Locale> supported, bool withCountry) {
    if (locale == null || !_isSupported(locale, withCountry)) {
      return fallback ?? supported.first;
    }

    final Locale languageLocale = Locale(locale.languageCode, "");
    if (supported.contains(locale)) {
      return locale;
    } else if (supported.contains(languageLocale)) {
      return languageLocale;
    } else {
      final Locale fallbackLocale = fallback ?? supported.first;
      return fallbackLocale;
    }
  }

  ///
  /// Returns true if the specified locale is supported, false otherwise.
  ///
  bool _isSupported(Locale locale, bool withCountry) {
    if (locale != null) {
      for (Locale supportedLocale in supportedLocales) {
        // Language must always match both locales.
        if (supportedLocale.languageCode != locale.languageCode) {
          continue;
        }

        // If country code matches, return this locale.
        if (supportedLocale.countryCode == locale.countryCode) {
          return true;
        }

        // If no country requirement is requested, check if this locale has no country.
        if (true != withCountry && (supportedLocale.countryCode == null || supportedLocale.countryCode.isEmpty)) {
          return true;
        }
      }
    }
    return false;
  }
}

String getLang(Locale l) => l == null
  ? null
  : l.countryCode != null && l.countryCode.isEmpty
    ? l.languageCode
    : l.toString();
